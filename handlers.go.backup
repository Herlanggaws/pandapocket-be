package main

import (
	"database/sql"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
)

func getCategoriesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		categoryType := c.Query("type") // Optional filter by type

		query := `
			SELECT id, user_id, name, color, is_default, category_type, created_at 
			FROM categories 
			WHERE (is_default = TRUE OR user_id = ?)
		`
		args := []interface{}{userID}

		if categoryType != "" {
			query += " AND category_type = ?"
			args = append(args, categoryType)
		}

		query += " ORDER BY is_default DESC, name ASC"

		rows, err := db.Query(query, args...)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch categories"})
			return
		}
		defer rows.Close()

		var categories []Category
		for rows.Next() {
			var cat Category
			var userIDPtr *int
			err := rows.Scan(&cat.ID, &userIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt)
			if err != nil {
				continue
			}
			cat.UserID = userIDPtr
			categories = append(categories, cat)
		}

		c.JSON(http.StatusOK, categories)
	}
}

func createCategoryHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateCategoryRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Set default color if not provided
		if req.Color == "" {
			req.Color = "#3B82F6"
		}

		result, err := db.Exec("INSERT INTO categories (user_id, name, color, category_type) VALUES (?, ?, ?, ?)", userID, req.Name, req.Color, req.Type)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create category"})
			return
		}

		categoryID, _ := result.LastInsertId()

		c.JSON(http.StatusCreated, gin.H{
			"message": "Category created successfully",
			"category": Category{
				ID:           int(categoryID),
				UserID:       &userID,
				Name:         req.Name,
				Color:        req.Color,
				CategoryType: req.Type,
				IsDefault:    false,
				CreatedAt:    time.Now(),
			},
		})
	}
}

func getExpensesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		rows, err := db.Query(`
			SELECT e.id, e.user_id, e.category_id, e.currency_id, e.amount, e.description, e.date, e.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM expenses e
			JOIN categories c ON e.category_id = c.id
			JOIN currencies curr ON e.currency_id = curr.id
			WHERE e.user_id = ?
			ORDER BY e.date DESC, e.created_at DESC
		`, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch expenses"})
			return
		}
		defer rows.Close()

		var expenses []Expense
		for rows.Next() {
			var exp Expense
			var cat Category
			var curr Currency
			var catUserIDPtr *int
			var currUserIDPtr *int
			err := rows.Scan(
				&exp.ID, &exp.UserID, &exp.CategoryID, &exp.CurrencyID, &exp.Amount, &exp.Description, &exp.Date, &exp.CreatedAt,
				&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
				&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
			)
			if err != nil {
				continue
			}
			cat.UserID = catUserIDPtr
			curr.UserID = currUserIDPtr
			exp.Category = cat
			exp.Currency = curr
			expenses = append(expenses, exp)
		}

		c.JSON(http.StatusOK, expenses)
	}
}

func createExpenseHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateExpenseRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Parse the date string to time.Time
		date, err := time.Parse("2006-01-02", req.Date)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid date format. Expected YYYY-MM-DD"})
			return
		}

		// Verify category exists and user has access to it, and it's an expense category
		var categoryExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM categories 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?) AND category_type = 'expense'
			)
		`, req.CategoryID, userID).Scan(&categoryExists)
		if err != nil || !categoryExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid expense category"})
			return
		}

		// Verify currency exists and user has access to it
		var currencyExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM currencies 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?)
			)
		`, req.CurrencyID, userID).Scan(&currencyExists)
		if err != nil || !currencyExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency"})
			return
		}

		result, err := db.Exec(`
			INSERT INTO expenses (user_id, category_id, currency_id, amount, description, date) 
			VALUES (?, ?, ?, ?, ?, ?)
		`, userID, req.CategoryID, req.CurrencyID, req.Amount, req.Description, date)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create expense"})
			return
		}

		expenseID, _ := result.LastInsertId()

		// Get the created expense with category and currency info
		var exp Expense
		var cat Category
		var curr Currency
		var catUserIDPtr *int
		var currUserIDPtr *int
		err = db.QueryRow(`
			SELECT e.id, e.user_id, e.category_id, e.currency_id, e.amount, e.description, e.date, e.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM expenses e
			JOIN categories c ON e.category_id = c.id
			JOIN currencies curr ON e.currency_id = curr.id
			WHERE e.id = ?
		`, expenseID).Scan(
			&exp.ID, &exp.UserID, &exp.CategoryID, &exp.CurrencyID, &exp.Amount, &exp.Description, &exp.Date, &exp.CreatedAt,
			&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
			&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch created expense"})
			return
		}
		cat.UserID = catUserIDPtr
		curr.UserID = currUserIDPtr
		exp.Category = cat
		exp.Currency = curr

		c.JSON(http.StatusCreated, gin.H{
			"message": "Expense created successfully",
			"expense": exp,
		})
	}
}

func deleteExpenseHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		expenseID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid expense ID"})
			return
		}

		result, err := db.Exec("DELETE FROM expenses WHERE id = ? AND user_id = ?", expenseID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete expense"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Expense not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Expense deleted successfully"})
	}
}

func getIncomesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		rows, err := db.Query(`
			SELECT i.id, i.user_id, i.category_id, i.currency_id, i.amount, i.description, i.date, i.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM incomes i
			JOIN categories c ON i.category_id = c.id
			JOIN currencies curr ON i.currency_id = curr.id
			WHERE i.user_id = ?
			ORDER BY i.date DESC, i.created_at DESC
		`, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch incomes"})
			return
		}
		defer rows.Close()

		var incomes []Income
		for rows.Next() {
			var inc Income
			var cat Category
			var curr Currency
			var catUserIDPtr *int
			var currUserIDPtr *int
			err := rows.Scan(
				&inc.ID, &inc.UserID, &inc.CategoryID, &inc.CurrencyID, &inc.Amount, &inc.Description, &inc.Date, &inc.CreatedAt,
				&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
				&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
			)
			if err != nil {
				continue
			}
			cat.UserID = catUserIDPtr
			curr.UserID = currUserIDPtr
			inc.Category = cat
			inc.Currency = curr
			incomes = append(incomes, inc)
		}

		c.JSON(http.StatusOK, incomes)
	}
}

func createIncomeHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateIncomeRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Parse the date string to time.Time
		date, err := time.Parse("2006-01-02", req.Date)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid date format. Expected YYYY-MM-DD"})
			return
		}

		// Verify category exists and user has access to it, and it's an income category
		var categoryExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM categories 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?) AND category_type = 'income'
			)
		`, req.CategoryID, userID).Scan(&categoryExists)
		if err != nil || !categoryExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid income category"})
			return
		}

		// Verify currency exists and user has access to it
		var currencyExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM currencies 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?)
			)
		`, req.CurrencyID, userID).Scan(&currencyExists)
		if err != nil || !currencyExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency"})
			return
		}

		result, err := db.Exec(`
			INSERT INTO incomes (user_id, category_id, currency_id, amount, description, date) 
			VALUES (?, ?, ?, ?, ?, ?)
		`, userID, req.CategoryID, req.CurrencyID, req.Amount, req.Description, date)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create income"})
			return
		}

		incomeID, _ := result.LastInsertId()

		// Get the created income with category and currency info
		var inc Income
		var cat Category
		var curr Currency
		var catUserIDPtr *int
		var currUserIDPtr *int
		err = db.QueryRow(`
			SELECT i.id, i.user_id, i.category_id, i.currency_id, i.amount, i.description, i.date, i.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM incomes i
			JOIN categories c ON i.category_id = c.id
			JOIN currencies curr ON i.currency_id = curr.id
			WHERE i.id = ?
		`, incomeID).Scan(
			&inc.ID, &inc.UserID, &inc.CategoryID, &inc.CurrencyID, &inc.Amount, &inc.Description, &inc.Date, &inc.CreatedAt,
			&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
			&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch created income"})
			return
		}
		cat.UserID = catUserIDPtr
		curr.UserID = currUserIDPtr
		inc.Category = cat
		inc.Currency = curr

		c.JSON(http.StatusCreated, gin.H{
			"message": "Income created successfully",
			"income":  inc,
		})
	}
}

func deleteIncomeHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		incomeID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid income ID"})
			return
		}

		result, err := db.Exec("DELETE FROM incomes WHERE id = ? AND user_id = ?", incomeID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete income"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Income not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Income deleted successfully"})
	}
}

func getCurrenciesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		log.Println("getCurrenciesHandler called")
		userID := c.GetInt("user_id")

		query := `
			SELECT id, user_id, code, name, symbol, is_default, created_at 
			FROM currencies 
			WHERE (is_default = 1 OR user_id = ?)
			ORDER BY is_default DESC, name ASC
		`

		rows, err := db.Query(query, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch currencies"})
			return
		}
		defer rows.Close()

		var currencies []Currency
		for rows.Next() {
			var curr Currency
			var userIDPtr *int
			err := rows.Scan(&curr.ID, &userIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt)
			if err != nil {
				continue
			}
			curr.UserID = userIDPtr
			currencies = append(currencies, curr)
		}

		c.JSON(http.StatusOK, currencies)
	}
}

func createCurrencyHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateCurrencyRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Check if currency code already exists for this user
		var exists bool
		err := db.QueryRow("SELECT EXISTS(SELECT 1 FROM currencies WHERE code = ? AND user_id = ?)", req.Code, userID).Scan(&exists)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check currency existence"})
			return
		}
		if exists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Currency code already exists"})
			return
		}

		result, err := db.Exec("INSERT INTO currencies (user_id, code, name, symbol) VALUES (?, ?, ?, ?)", userID, req.Code, req.Name, req.Symbol)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create currency"})
			return
		}

		currencyID, _ := result.LastInsertId()

		c.JSON(http.StatusCreated, gin.H{
			"message": "Currency created successfully",
			"currency": Currency{
				ID:        int(currencyID),
				UserID:    &userID,
				Code:      req.Code,
				Name:      req.Name,
				Symbol:    req.Symbol,
				IsDefault: false,
				CreatedAt: time.Now(),
			},
		})
	}
}

func updateCurrencyHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		currencyID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency ID"})
			return
		}

		var req UpdateCurrencyRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Check if currency belongs to user or is default
		var isDefault bool
		var currencyUserID *int
		err = db.QueryRow("SELECT is_default, user_id FROM currencies WHERE id = ?", currencyID).Scan(&isDefault, &currencyUserID)
		if err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "Currency not found"})
			return
		}

		// Only allow updates to user's own currencies or default currencies
		if !isDefault && (currencyUserID == nil || *currencyUserID != userID) {
			c.JSON(http.StatusForbidden, gin.H{"error": "Cannot update this currency"})
			return
		}

		// Check if currency code already exists for this user (excluding current currency)
		var exists bool
		err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM currencies WHERE code = ? AND user_id = ? AND id != ?)", req.Code, userID, currencyID).Scan(&exists)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check currency existence"})
			return
		}
		if exists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Currency code already exists"})
			return
		}

		_, err = db.Exec("UPDATE currencies SET code = ?, name = ?, symbol = ? WHERE id = ?", req.Code, req.Name, req.Symbol, currencyID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update currency"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Currency updated successfully"})
	}
}

func deleteCurrencyHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		currencyID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency ID"})
			return
		}

		// Check if currency belongs to user and is not default
		var isDefault bool
		var currencyUserID *int
		err = db.QueryRow("SELECT is_default, user_id FROM currencies WHERE id = ?", currencyID).Scan(&isDefault, &currencyUserID)
		if err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "Currency not found"})
			return
		}

		if isDefault {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot delete default currency"})
			return
		}

		if currencyUserID == nil || *currencyUserID != userID {
			c.JSON(http.StatusForbidden, gin.H{"error": "Cannot delete this currency"})
			return
		}

		result, err := db.Exec("DELETE FROM currencies WHERE id = ?", currencyID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete currency"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Currency not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Currency deleted successfully"})
	}
}

// Budget handlers
func getBudgetsHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		rows, err := db.Query(`
			SELECT b.id, b.user_id, b.category_id, b.amount, b.period, b.start_date, b.end_date, b.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at
			FROM budgets b
			JOIN categories c ON b.category_id = c.id
			WHERE b.user_id = ?
			ORDER BY b.created_at DESC
		`, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch budgets"})
			return
		}
		defer rows.Close()

		var budgets []Budget
		for rows.Next() {
			var budget Budget
			var cat Category
			var catUserIDPtr *int
			err := rows.Scan(
				&budget.ID, &budget.UserID, &budget.CategoryID, &budget.Amount, &budget.Period, &budget.StartDate, &budget.EndDate, &budget.CreatedAt,
				&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
			)
			if err != nil {
				continue
			}
			cat.UserID = catUserIDPtr
			budget.Category = cat

			// Calculate spent amount and progress
			var spentAmount float64
			err = db.QueryRow(`
				SELECT COALESCE(SUM(amount), 0)
				FROM expenses
				WHERE user_id = ? AND category_id = ? AND date BETWEEN ? AND ?
			`, userID, budget.CategoryID, budget.StartDate, budget.EndDate).Scan(&spentAmount)
			if err == nil {
				budget.SpentAmount = spentAmount
				budget.Remaining = budget.Amount - spentAmount
				if budget.Amount > 0 {
					budget.Progress = (spentAmount / budget.Amount) * 100
				}
			}

			budgets = append(budgets, budget)
		}

		c.JSON(http.StatusOK, budgets)
	}
}

func createBudgetHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateBudgetRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Parse the start date
		startDate, err := time.Parse("2006-01-02", req.StartDate)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid start date format. Expected YYYY-MM-DD"})
			return
		}

		// Calculate end date based on period
		var endDate time.Time
		switch req.Period {
		case "weekly":
			endDate = startDate.AddDate(0, 0, 7)
		case "monthly":
			endDate = startDate.AddDate(0, 1, 0)
		case "yearly":
			endDate = startDate.AddDate(1, 0, 0)
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid period"})
			return
		}

		// Verify category exists and user has access to it
		var categoryExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM categories 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?) AND category_type = 'expense'
			)
		`, req.CategoryID, userID).Scan(&categoryExists)
		if err != nil || !categoryExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid expense category"})
			return
		}

		result, err := db.Exec(`
			INSERT INTO budgets (user_id, category_id, amount, period, start_date, end_date) 
			VALUES (?, ?, ?, ?, ?, ?)
		`, userID, req.CategoryID, req.Amount, req.Period, startDate, endDate)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create budget"})
			return
		}

		budgetID, _ := result.LastInsertId()

		// Get the created budget with category info
		var budget Budget
		var cat Category
		var catUserIDPtr *int
		err = db.QueryRow(`
			SELECT b.id, b.user_id, b.category_id, b.amount, b.period, b.start_date, b.end_date, b.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at
			FROM budgets b
			JOIN categories c ON b.category_id = c.id
			WHERE b.id = ?
		`, budgetID).Scan(
			&budget.ID, &budget.UserID, &budget.CategoryID, &budget.Amount, &budget.Period, &budget.StartDate, &budget.EndDate, &budget.CreatedAt,
			&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch created budget"})
			return
		}
		cat.UserID = catUserIDPtr
		budget.Category = cat

		c.JSON(http.StatusCreated, gin.H{
			"message": "Budget created successfully",
			"budget":  budget,
		})
	}
}

func deleteBudgetHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		budgetID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid budget ID"})
			return
		}

		result, err := db.Exec("DELETE FROM budgets WHERE id = ? AND user_id = ?", budgetID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete budget"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Budget not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Budget deleted successfully"})
	}
}

// Recurring transaction handlers
func getRecurringTransactionsHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		rows, err := db.Query(`
			SELECT rt.id, rt.user_id, rt.category_id, rt.currency_id, rt.amount, rt.description, rt.frequency, rt.next_due_date, rt.is_active, rt.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM recurring_transactions rt
			JOIN categories c ON rt.category_id = c.id
			JOIN currencies curr ON rt.currency_id = curr.id
			WHERE rt.user_id = ?
			ORDER BY rt.next_due_date ASC
		`, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch recurring transactions"})
			return
		}
		defer rows.Close()

		var recurringTransactions []RecurringTransaction
		for rows.Next() {
			var rt RecurringTransaction
			var cat Category
			var curr Currency
			var catUserIDPtr *int
			var currUserIDPtr *int
			err := rows.Scan(
				&rt.ID, &rt.UserID, &rt.CategoryID, &rt.CurrencyID, &rt.Amount, &rt.Description, &rt.Frequency, &rt.NextDueDate, &rt.IsActive, &rt.CreatedAt,
				&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
				&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
			)
			if err != nil {
				continue
			}
			cat.UserID = catUserIDPtr
			curr.UserID = currUserIDPtr
			rt.Category = cat
			rt.Currency = curr
			recurringTransactions = append(recurringTransactions, rt)
		}

		c.JSON(http.StatusOK, recurringTransactions)
	}
}

func createRecurringTransactionHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req CreateRecurringTransactionRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Parse the next due date
		nextDueDate, err := time.Parse("2006-01-02", req.NextDueDate)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid next due date format. Expected YYYY-MM-DD"})
			return
		}

		// Verify category exists and user has access to it
		var categoryExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM categories 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?)
			)
		`, req.CategoryID, userID).Scan(&categoryExists)
		if err != nil || !categoryExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category"})
			return
		}

		// Verify currency exists and user has access to it
		var currencyExists bool
		err = db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM currencies 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?)
			)
		`, req.CurrencyID, userID).Scan(&currencyExists)
		if err != nil || !currencyExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency"})
			return
		}

		result, err := db.Exec(`
			INSERT INTO recurring_transactions (user_id, category_id, currency_id, amount, description, frequency, next_due_date) 
			VALUES (?, ?, ?, ?, ?, ?, ?)
		`, userID, req.CategoryID, req.CurrencyID, req.Amount, req.Description, req.Frequency, nextDueDate)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create recurring transaction"})
			return
		}

		recurringTransactionID, _ := result.LastInsertId()

		// Get the created recurring transaction with category and currency info
		var rt RecurringTransaction
		var cat Category
		var curr Currency
		var catUserIDPtr *int
		var currUserIDPtr *int
		err = db.QueryRow(`
			SELECT rt.id, rt.user_id, rt.category_id, rt.currency_id, rt.amount, rt.description, rt.frequency, rt.next_due_date, rt.is_active, rt.created_at,
				   c.id, c.user_id, c.name, c.color, c.is_default, c.category_type, c.created_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM recurring_transactions rt
			JOIN categories c ON rt.category_id = c.id
			JOIN currencies curr ON rt.currency_id = curr.id
			WHERE rt.id = ?
		`, recurringTransactionID).Scan(
			&rt.ID, &rt.UserID, &rt.CategoryID, &rt.CurrencyID, &rt.Amount, &rt.Description, &rt.Frequency, &rt.NextDueDate, &rt.IsActive, &rt.CreatedAt,
			&cat.ID, &catUserIDPtr, &cat.Name, &cat.Color, &cat.IsDefault, &cat.CategoryType, &cat.CreatedAt,
			&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch created recurring transaction"})
			return
		}
		cat.UserID = catUserIDPtr
		curr.UserID = currUserIDPtr
		rt.Category = cat
		rt.Currency = curr

		c.JSON(http.StatusCreated, gin.H{
			"message":               "Recurring transaction created successfully",
			"recurring_transaction": rt,
		})
	}
}

func deleteRecurringTransactionHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		recurringTransactionID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid recurring transaction ID"})
			return
		}

		result, err := db.Exec("DELETE FROM recurring_transactions WHERE id = ? AND user_id = ?", recurringTransactionID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete recurring transaction"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Recurring transaction not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Recurring transaction deleted successfully"})
	}
}

// Analytics handlers
func getAnalyticsHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		period := c.Query("period") // weekly, monthly, yearly
		if period == "" {
			period = "monthly"
		}

		// Get user's primary currency for conversion
		var primaryCurrencyID int
		err := db.QueryRow(`
			SELECT COALESCE(up.primary_currency_id, 
				(SELECT id FROM currencies WHERE is_default = TRUE LIMIT 1))
			FROM user_preferences up
			WHERE up.user_id = ?
		`, userID).Scan(&primaryCurrencyID)
		if err != nil {
			// Fallback to default currency
			err = db.QueryRow("SELECT id FROM currencies WHERE is_default = TRUE LIMIT 1").Scan(&primaryCurrencyID)
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "No default currency found"})
				return
			}
		}

		// Calculate date range based on period
		now := time.Now()
		var startDate time.Time
		switch period {
		case "weekly":
			startDate = now.AddDate(0, 0, -7)
		case "monthly":
			startDate = now.AddDate(0, -1, 0)
		case "yearly":
			startDate = now.AddDate(-1, 0, 0)
		default:
			startDate = now.AddDate(0, -1, 0) // Default to monthly
		}

		// Get spending by category
		rows, err := db.Query(`
			SELECT c.id, c.name, c.color, COALESCE(SUM(e.amount), 0) as total_amount
			FROM categories c
			LEFT JOIN expenses e ON c.id = e.category_id AND e.user_id = ? AND e.date >= ?
			WHERE c.category_type = 'expense' AND (c.is_default = TRUE OR c.user_id = ?)
			GROUP BY c.id, c.name, c.color
			HAVING total_amount > 0
			ORDER BY total_amount DESC
		`, userID, startDate, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch spending by category"})
			return
		}
		defer rows.Close()

		var spendingByCategory []SpendingByCategory
		var totalSpent float64
		for rows.Next() {
			var sbc SpendingByCategory
			err := rows.Scan(&sbc.CategoryID, &sbc.CategoryName, &sbc.CategoryColor, &sbc.Amount)
			if err != nil {
				continue
			}
			totalSpent += sbc.Amount
			spendingByCategory = append(spendingByCategory, sbc)
		}

		// Calculate percentages
		for i := range spendingByCategory {
			if totalSpent > 0 {
				spendingByCategory[i].Percentage = (spendingByCategory[i].Amount / totalSpent) * 100
			}
		}

		// Get spending by period (daily/weekly/monthly breakdown)
		var spendingByPeriod []SpendingByPeriod
		var periodQuery string
		var groupByClause string

		// Check if we're using SQLite or PostgreSQL
		dbType := os.Getenv("DB_TYPE")
		if dbType == "" {
			dbType = "sqlite" // default
		}

		if dbType == "sqlite" {
			switch period {
			case "weekly":
				periodQuery = "strftime('%Y-%m-%d', e.date) as period"
			case "monthly":
				periodQuery = "strftime('%Y-%m', e.date) as period"
			case "yearly":
				periodQuery = "strftime('%Y', e.date) as period"
			}
			groupByClause = "GROUP BY period"
		} else {
			// PostgreSQL
			switch period {
			case "weekly":
				periodQuery = "TO_CHAR(e.date, 'YYYY-MM-DD') as period"
			case "monthly":
				periodQuery = "TO_CHAR(e.date, 'YYYY-MM') as period"
			case "yearly":
				periodQuery = "TO_CHAR(e.date, 'YYYY') as period"
			}
			groupByClause = "GROUP BY period"
		}

		rows, err = db.Query(`
			SELECT `+periodQuery+`, COALESCE(SUM(e.amount), 0) as total_amount
			FROM expenses e
			WHERE e.user_id = ? AND e.date >= ?
			`+groupByClause+`
			ORDER BY period ASC
		`, userID, startDate)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch spending by period"})
			return
		}
		defer rows.Close()

		for rows.Next() {
			var sbp SpendingByPeriod
			err := rows.Scan(&sbp.Date, &sbp.Amount)
			if err != nil {
				continue
			}
			sbp.Period = period
			spendingByPeriod = append(spendingByPeriod, sbp)
		}

		// Get total income for the period
		var totalIncome float64
		err = db.QueryRow(`
			SELECT COALESCE(SUM(amount), 0)
			FROM incomes
			WHERE user_id = ? AND date >= ?
		`, userID, startDate).Scan(&totalIncome)
		if err != nil {
			totalIncome = 0
		}

		response := AnalyticsResponse{
			SpendingByCategory: spendingByCategory,
			SpendingByPeriod:   spendingByPeriod,
			TotalSpent:         totalSpent,
			TotalIncome:        totalIncome,
			NetAmount:          totalIncome - totalSpent,
		}

		c.JSON(http.StatusOK, response)
	}
}

// User preferences handlers
func getUserPreferencesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var prefs UserPreferences
		var curr Currency
		var currUserIDPtr *int
		err := db.QueryRow(`
			SELECT up.id, up.user_id, up.primary_currency_id, up.email_notifications, up.budget_alerts, up.recurring_reminders, up.created_at, up.updated_at,
				   curr.id, curr.user_id, curr.code, curr.name, curr.symbol, curr.is_default, curr.created_at
			FROM user_preferences up
			JOIN currencies curr ON up.primary_currency_id = curr.id
			WHERE up.user_id = ?
		`, userID).Scan(
			&prefs.ID, &prefs.UserID, &prefs.PrimaryCurrencyID, &prefs.EmailNotifications, &prefs.BudgetAlerts, &prefs.RecurringReminders, &prefs.CreatedAt, &prefs.UpdatedAt,
			&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
		)
		if err != nil {
			if err == sql.ErrNoRows {
				// Create default preferences
				err = db.QueryRow("SELECT id FROM currencies WHERE is_default = TRUE LIMIT 1").Scan(&prefs.PrimaryCurrencyID)
				if err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "No default currency found"})
					return
				}

				result, err := db.Exec(`
					INSERT INTO user_preferences (user_id, primary_currency_id, email_notifications, budget_alerts, recurring_reminders)
					VALUES (?, ?, TRUE, TRUE, TRUE)
				`, userID, prefs.PrimaryCurrencyID)
				if err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user preferences"})
					return
				}

				prefsID, _ := result.LastInsertId()
				prefs.ID = int(prefsID)
				prefs.UserID = userID
				prefs.EmailNotifications = true
				prefs.BudgetAlerts = true
				prefs.RecurringReminders = true
				prefs.CreatedAt = time.Now()
				prefs.UpdatedAt = time.Now()

				// Get currency info
				err = db.QueryRow(`
					SELECT id, user_id, code, name, symbol, is_default, created_at
					FROM currencies WHERE id = ?
				`, prefs.PrimaryCurrencyID).Scan(
					&curr.ID, &currUserIDPtr, &curr.Code, &curr.Name, &curr.Symbol, &curr.IsDefault, &curr.CreatedAt,
				)
				if err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch currency info"})
					return
				}
			} else {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user preferences"})
				return
			}
		}

		curr.UserID = currUserIDPtr
		prefs.PrimaryCurrency = curr

		c.JSON(http.StatusOK, prefs)
	}
}

func updateUserPreferencesHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		var req UpdateUserPreferencesRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Verify currency exists and user has access to it
		var currencyExists bool
		err := db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM currencies 
				WHERE id = ? AND (is_default = TRUE OR user_id = ?)
			)
		`, req.PrimaryCurrencyID, userID).Scan(&currencyExists)
		if err != nil || !currencyExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid currency"})
			return
		}

		// Update or insert user preferences
		// Check if we're using SQLite or PostgreSQL
		dbType := os.Getenv("DB_TYPE")
		if dbType == "" {
			dbType = "sqlite" // default
		}

		if dbType == "postgres" {
			_, err = db.Exec(`
				INSERT INTO user_preferences (user_id, primary_currency_id, email_notifications, budget_alerts, recurring_reminders, updated_at)
				VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
				ON CONFLICT(user_id) DO UPDATE SET
					primary_currency_id = EXCLUDED.primary_currency_id,
					email_notifications = EXCLUDED.email_notifications,
					budget_alerts = EXCLUDED.budget_alerts,
					recurring_reminders = EXCLUDED.recurring_reminders,
					updated_at = CURRENT_TIMESTAMP
			`, userID, req.PrimaryCurrencyID, req.EmailNotifications, req.BudgetAlerts, req.RecurringReminders)
		} else {
			// SQLite - use REPLACE INTO
			_, err = db.Exec(`
				REPLACE INTO user_preferences (user_id, primary_currency_id, email_notifications, budget_alerts, recurring_reminders, updated_at)
				VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
			`, userID, req.PrimaryCurrencyID, req.EmailNotifications, req.BudgetAlerts, req.RecurringReminders)
		}
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user preferences"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "User preferences updated successfully"})
	}
}

// Notification handlers
func getNotificationsHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")

		rows, err := db.Query(`
			SELECT id, user_id, title, message, type, is_read, created_at
			FROM notifications
			WHERE user_id = ?
			ORDER BY created_at DESC
			LIMIT 50
		`, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch notifications"})
			return
		}
		defer rows.Close()

		var notifications []Notification
		for rows.Next() {
			var notif Notification
			err := rows.Scan(&notif.ID, &notif.UserID, &notif.Title, &notif.Message, &notif.Type, &notif.IsRead, &notif.CreatedAt)
			if err != nil {
				continue
			}
			notifications = append(notifications, notif)
		}

		c.JSON(http.StatusOK, notifications)
	}
}

func markNotificationReadHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		notificationID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid notification ID"})
			return
		}

		result, err := db.Exec("UPDATE notifications SET is_read = TRUE WHERE id = ? AND user_id = ?", notificationID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to mark notification as read"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Notification not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Notification marked as read"})
	}
}

func deleteNotificationHandler(db *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetInt("user_id")
		notificationID, err := strconv.Atoi(c.Param("id"))
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid notification ID"})
			return
		}

		result, err := db.Exec("DELETE FROM notifications WHERE id = ? AND user_id = ?", notificationID, userID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete notification"})
			return
		}

		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "Notification not found"})
			return
		}

		c.JSON(http.StatusOK, gin.H{"message": "Notification deleted successfully"})
	}
}
