package database

import (
	"context"
	"database/sql"
	"fmt"
	"panda-pocket/internal/domain/finance"
	"time"
)

// PostgresTransactionRepository implements the TransactionRepository interface using PostgreSQL
type PostgresTransactionRepository struct {
	db *sql.DB
}

// NewPostgresTransactionRepository creates a new PostgreSQL transaction repository
func NewPostgresTransactionRepository(db *sql.DB) *PostgresTransactionRepository {
	return &PostgresTransactionRepository{db: db}
}

// Save saves a transaction to the database
func (r *PostgresTransactionRepository) Save(ctx context.Context, transaction *finance.Transaction) error {
	if transaction.ID().Value() == 0 {
		// Insert new transaction
		var tableName string
		if transaction.Type() == finance.TransactionTypeExpense {
			tableName = "expenses"
		} else {
			tableName = "incomes"
		}

		query := fmt.Sprintf("INSERT INTO %s (user_id, category_id, currency_id, amount, description, date, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7)", tableName)
		_, err := r.db.ExecContext(ctx, query,
			transaction.UserID().Value(),
			transaction.CategoryID().Value(),
			transaction.CurrencyID().Value(),
			transaction.Amount().Amount(),
			transaction.Description(),
			transaction.Date(),
			transaction.CreatedAt(),
		)
		if err != nil {
			return err
		}

		// Note: PostgreSQL doesn't support LastInsertId() like SQLite
		// The ID will be auto-generated by the SERIAL column
	} else {
		// Update existing transaction
		var tableName string
		if transaction.Type() == finance.TransactionTypeExpense {
			tableName = "expenses"
		} else {
			tableName = "incomes"
		}

		query := fmt.Sprintf("UPDATE %s SET category_id = $1, currency_id = $2, amount = $3, description = $4, date = $5 WHERE id = $6", tableName)
		_, err := r.db.ExecContext(ctx, query,
			transaction.CategoryID().Value(),
			transaction.CurrencyID().Value(),
			transaction.Amount().Amount(),
			transaction.Description(),
			transaction.Date(),
			transaction.ID().Value(),
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// FindByID finds a transaction by ID
func (r *PostgresTransactionRepository) FindByID(ctx context.Context, id finance.TransactionID) (*finance.Transaction, error) {
	// Try to find in expenses table first
	var userID, categoryID, currencyID int
	var amount float64
	var description string
	var date time.Time
	var createdAt time.Time

	err := r.db.QueryRowContext(ctx,
		"SELECT user_id, category_id, currency_id, amount, description, date, created_at FROM expenses WHERE id = $1",
		id.Value(),
	).Scan(&userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)

	if err == nil {
		// Found in expenses table
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(id, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeExpense)
		return transaction, nil
	}

	if err != sql.ErrNoRows {
		return nil, err
	}

	// Try to find in incomes table
	err = r.db.QueryRowContext(ctx,
		"SELECT user_id, category_id, currency_id, amount, description, date, created_at FROM incomes WHERE id = $1",
		id.Value(),
	).Scan(&userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, err
	}

	// Found in incomes table
	userIDVO := finance.NewUserID(userID)
	categoryIDVO := finance.NewCategoryID(categoryID)
	currencyIDVO := finance.NewCurrencyID(currencyID)
	amountVO, err := finance.NewMoney(amount, currencyIDVO)
	if err != nil {
		return nil, err
	}

	transaction := finance.NewTransaction(id, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeIncome)
	return transaction, nil
}

// FindByUserID finds all transactions for a user
func (r *PostgresTransactionRepository) FindByUserID(ctx context.Context, userID finance.UserID) ([]*finance.Transaction, error) {
	var transactions []*finance.Transaction

	// Get expenses
	expenseRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM expenses WHERE user_id = $1 ORDER BY date DESC",
		userID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer expenseRows.Close()

	for expenseRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := expenseRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeExpense)
		transactions = append(transactions, transaction)
	}

	// Get incomes
	incomeRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM incomes WHERE user_id = $1 ORDER BY date DESC",
		userID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer incomeRows.Close()

	for incomeRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := incomeRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeIncome)
		transactions = append(transactions, transaction)
	}

	return transactions, nil
}

// Delete deletes a transaction by ID
func (r *PostgresTransactionRepository) Delete(ctx context.Context, id finance.TransactionID) error {
	// Try to delete from expenses table first
	result, err := r.db.ExecContext(ctx, "DELETE FROM expenses WHERE id = $1", id.Value())
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected > 0 {
		return nil
	}

	// Try to delete from incomes table
	_, err = r.db.ExecContext(ctx, "DELETE FROM incomes WHERE id = $1", id.Value())
	return err
}

// ExistsByID checks if a transaction exists with the given ID
func (r *PostgresTransactionRepository) ExistsByID(ctx context.Context, id finance.TransactionID) (bool, error) {
	var count int

	// Check in expenses table
	err := r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM expenses WHERE id = $1",
		id.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	if count > 0 {
		return true, nil
	}

	// Check in incomes table
	err = r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM incomes WHERE id = $1",
		id.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// FindByUserIDAndDateRange finds transactions for a user within a date range
func (r *PostgresTransactionRepository) FindByUserIDAndDateRange(ctx context.Context, userID finance.UserID, startDate, endDate time.Time) ([]*finance.Transaction, error) {
	var transactions []*finance.Transaction

	// Get expenses
	expenseRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3 ORDER BY date DESC",
		userID.Value(),
		startDate,
		endDate,
	)
	if err != nil {
		return nil, err
	}
	defer expenseRows.Close()

	for expenseRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := expenseRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeExpense)
		transactions = append(transactions, transaction)
	}

	// Get incomes
	incomeRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3 ORDER BY date DESC",
		userID.Value(),
		startDate,
		endDate,
	)
	if err != nil {
		return nil, err
	}
	defer incomeRows.Close()

	for incomeRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := incomeRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeIncome)
		transactions = append(transactions, transaction)
	}

	return transactions, nil
}

// FindByUserIDAndCategory finds transactions for a user by category
func (r *PostgresTransactionRepository) FindByUserIDAndCategory(ctx context.Context, userID finance.UserID, categoryID finance.CategoryID) ([]*finance.Transaction, error) {
	var transactions []*finance.Transaction

	// Get expenses
	expenseRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM expenses WHERE user_id = $1 AND category_id = $2 ORDER BY date DESC",
		userID.Value(),
		categoryID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer expenseRows.Close()

	for expenseRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := expenseRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeExpense)
		transactions = append(transactions, transaction)
	}

	// Get incomes
	incomeRows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, category_id, currency_id, amount, description, date, created_at FROM incomes WHERE user_id = $1 AND category_id = $2 ORDER BY date DESC",
		userID.Value(),
		categoryID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer incomeRows.Close()

	for incomeRows.Next() {
		var id, userID, categoryID, currencyID int
		var amount float64
		var description string
		var date, createdAt time.Time

		err := incomeRows.Scan(&id, &userID, &categoryID, &currencyID, &amount, &description, &date, &createdAt)
		if err != nil {
			return nil, err
		}

		transactionID := finance.NewTransactionID(id)
		userIDVO := finance.NewUserID(userID)
		categoryIDVO := finance.NewCategoryID(categoryID)
		currencyIDVO := finance.NewCurrencyID(currencyID)
		amountVO, err := finance.NewMoney(amount, currencyIDVO)
		if err != nil {
			return nil, err
		}

		transaction := finance.NewTransaction(transactionID, userIDVO, categoryIDVO, currencyIDVO, amountVO, description, date, finance.TransactionTypeIncome)
		transactions = append(transactions, transaction)
	}

	return transactions, nil
}
