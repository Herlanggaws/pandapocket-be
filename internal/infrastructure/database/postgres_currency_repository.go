package database

import (
	"context"
	"database/sql"
	"panda-pocket/internal/domain/finance"
)

// PostgresCurrencyRepository implements the CurrencyRepository interface using PostgreSQL
type PostgresCurrencyRepository struct {
	db *sql.DB
}

// NewPostgresCurrencyRepository creates a new PostgreSQL currency repository
func NewPostgresCurrencyRepository(db *sql.DB) *PostgresCurrencyRepository {
	return &PostgresCurrencyRepository{db: db}
}

// Save saves a currency to the database
func (r *PostgresCurrencyRepository) Save(ctx context.Context, currency *finance.Currency) error {
	if currency.ID().Value() == 0 {
		// Insert new currency
		_, err := r.db.ExecContext(ctx,
			"INSERT INTO currencies (user_id, code, name, symbol, is_default, created_at) VALUES ($1, $2, $3, $4, $5, $6)",
			currency.UserID().Value(),
			currency.Code(),
			currency.Name(),
			currency.Symbol(),
			currency.IsDefault(),
			currency.CreatedAt(),
		)
		if err != nil {
			return err
		}

		// Note: PostgreSQL doesn't support LastInsertId() like SQLite
		// The ID will be auto-generated by the SERIAL column
	} else {
		// Update existing currency
		_, err := r.db.ExecContext(ctx,
			"UPDATE currencies SET code = $1, name = $2, symbol = $3 WHERE id = $4",
			currency.Code(),
			currency.Name(),
			currency.Symbol(),
			currency.ID().Value(),
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// FindByID finds a currency by ID
func (r *PostgresCurrencyRepository) FindByID(ctx context.Context, id finance.CurrencyID) (*finance.Currency, error) {
	var userID int
	var code, name, symbol string
	var isDefault bool
	var createdAt string

	err := r.db.QueryRowContext(ctx,
		"SELECT user_id, code, name, symbol, is_default, created_at FROM currencies WHERE id = $1",
		id.Value(),
	).Scan(&userID, &code, &name, &symbol, &isDefault, &createdAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, err
	}

	userIDVO := finance.NewUserID(userID)

	currency, err := finance.NewCurrency(id, &userIDVO, code, name, symbol, isDefault)
	if err != nil {
		return nil, err
	}

	return currency, nil
}

// FindByUserID finds all currencies for a user
func (r *PostgresCurrencyRepository) FindByUserID(ctx context.Context, userID finance.UserID) ([]*finance.Currency, error) {
	rows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, code, name, symbol, is_default, created_at FROM currencies WHERE user_id = $1 OR is_default = TRUE ORDER BY is_default DESC, code ASC",
		userID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var currencies []*finance.Currency
	for rows.Next() {
		var id, userID int
		var code, name, symbol string
		var isDefault bool
		var createdAt string

		err := rows.Scan(&id, &userID, &code, &name, &symbol, &isDefault, &createdAt)
		if err != nil {
			return nil, err
		}

		currencyID := finance.NewCurrencyID(id)
		userIDVO := finance.NewUserID(userID)

		currency, err := finance.NewCurrency(currencyID, &userIDVO, code, name, symbol, isDefault)
		if err != nil {
			return nil, err
		}
		currencies = append(currencies, currency)
	}

	return currencies, rows.Err()
}

// Delete deletes a currency by ID
func (r *PostgresCurrencyRepository) Delete(ctx context.Context, id finance.CurrencyID) error {
	_, err := r.db.ExecContext(ctx, "DELETE FROM currencies WHERE id = $1", id.Value())
	return err
}

// ExistsByID checks if a currency exists with the given ID
func (r *PostgresCurrencyRepository) ExistsByID(ctx context.Context, id finance.CurrencyID) (bool, error) {
	var count int
	err := r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM currencies WHERE id = $1",
		id.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// FindDefaultCurrencies finds all default currencies
func (r *PostgresCurrencyRepository) FindDefaultCurrencies(ctx context.Context) ([]*finance.Currency, error) {
	rows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, code, name, symbol, is_default, created_at FROM currencies WHERE is_default = TRUE ORDER BY code ASC",
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var currencies []*finance.Currency
	for rows.Next() {
		var id, userID int
		var code, name, symbol string
		var isDefault bool
		var createdAt string

		err := rows.Scan(&id, &userID, &code, &name, &symbol, &isDefault, &createdAt)
		if err != nil {
			return nil, err
		}

		currencyID := finance.NewCurrencyID(id)
		userIDVO := finance.NewUserID(userID)

		currency, err := finance.NewCurrency(currencyID, &userIDVO, code, name, symbol, isDefault)
		if err != nil {
			return nil, err
		}
		currencies = append(currencies, currency)
	}

	return currencies, rows.Err()
}

// ExistsByCodeAndUserID checks if a currency exists with the given code and user ID
func (r *PostgresCurrencyRepository) ExistsByCodeAndUserID(ctx context.Context, code string, userID finance.UserID) (bool, error) {
	var count int
	err := r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM currencies WHERE code = $1 AND (user_id = $2 OR is_default = TRUE)",
		code,
		userID.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count > 0, nil
}
