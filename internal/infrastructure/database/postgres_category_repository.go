package database

import (
	"context"
	"database/sql"
	"panda-pocket/internal/domain/finance"
)

// PostgresCategoryRepository implements the CategoryRepository interface using PostgreSQL
type PostgresCategoryRepository struct {
	db *sql.DB
}

// NewPostgresCategoryRepository creates a new PostgreSQL category repository
func NewPostgresCategoryRepository(db *sql.DB) *PostgresCategoryRepository {
	return &PostgresCategoryRepository{db: db}
}

// Save saves a category to the database
func (r *PostgresCategoryRepository) Save(ctx context.Context, category *finance.Category) error {
	if category.ID().Value() == 0 {
		// Insert new category
		_, err := r.db.ExecContext(ctx,
			"INSERT INTO categories (user_id, name, color, is_default, category_type, created_at) VALUES ($1, $2, $3, $4, $5, $6)",
			category.UserID().Value(),
			category.Name(),
			category.Color(),
			category.IsDefault(),
			string(category.Type()),
			category.CreatedAt(),
		)
		if err != nil {
			return err
		}

		// Note: PostgreSQL doesn't support LastInsertId() like SQLite
		// The ID will be auto-generated by the SERIAL column
	} else {
		// Update existing category
		_, err := r.db.ExecContext(ctx,
			"UPDATE categories SET name = $1, color = $2, category_type = $3 WHERE id = $4",
			category.Name(),
			category.Color(),
			string(category.Type()),
			category.ID().Value(),
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// FindByID finds a category by ID
func (r *PostgresCategoryRepository) FindByID(ctx context.Context, id finance.CategoryID) (*finance.Category, error) {
	var userID int
	var name, color, categoryType string
	var isDefault bool
	var createdAt string

	err := r.db.QueryRowContext(ctx,
		"SELECT user_id, name, color, is_default, category_type, created_at FROM categories WHERE id = $1",
		id.Value(),
	).Scan(&userID, &name, &color, &isDefault, &categoryType, &createdAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, err
	}

	userIDVO := finance.NewUserID(userID)
	categoryTypeVO := finance.CategoryType(categoryType)

	category, err := finance.NewCategory(id, &userIDVO, name, color, isDefault, categoryTypeVO)
	if err != nil {
		return nil, err
	}

	return category, nil
}

// FindByUserID finds all categories for a user
func (r *PostgresCategoryRepository) FindByUserID(ctx context.Context, userID finance.UserID) ([]*finance.Category, error) {
	rows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, name, color, is_default, category_type, created_at FROM categories WHERE user_id = $1 OR is_default = TRUE ORDER BY is_default DESC, name ASC",
		userID.Value(),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var categories []*finance.Category
	for rows.Next() {
		var id, userID int
		var name, color, categoryType string
		var isDefault bool
		var createdAt string

		err := rows.Scan(&id, &userID, &name, &color, &isDefault, &categoryType, &createdAt)
		if err != nil {
			return nil, err
		}

		categoryID := finance.NewCategoryID(id)
		userIDVO := finance.NewUserID(userID)
		categoryTypeVO := finance.CategoryType(categoryType)

		category, err := finance.NewCategory(categoryID, &userIDVO, name, color, isDefault, categoryTypeVO)
		if err != nil {
			return nil, err
		}
		categories = append(categories, category)
	}

	return categories, rows.Err()
}

// Delete deletes a category by ID
func (r *PostgresCategoryRepository) Delete(ctx context.Context, id finance.CategoryID) error {
	_, err := r.db.ExecContext(ctx, "DELETE FROM categories WHERE id = $1", id.Value())
	return err
}

// ExistsByID checks if a category exists with the given ID
func (r *PostgresCategoryRepository) ExistsByID(ctx context.Context, id finance.CategoryID) (bool, error) {
	var count int
	err := r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM categories WHERE id = $1",
		id.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// FindByUserIDAndType finds categories for a user by type
func (r *PostgresCategoryRepository) FindByUserIDAndType(ctx context.Context, userID finance.UserID, categoryType finance.CategoryType) ([]*finance.Category, error) {
	rows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, name, color, is_default, category_type, created_at FROM categories WHERE (user_id = $1 OR is_default = TRUE) AND category_type = $2 ORDER BY is_default DESC, name ASC",
		userID.Value(),
		string(categoryType),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var categories []*finance.Category
	for rows.Next() {
		var id, userID int
		var name, color, categoryType string
		var isDefault bool
		var createdAt string

		err := rows.Scan(&id, &userID, &name, &color, &isDefault, &categoryType, &createdAt)
		if err != nil {
			return nil, err
		}

		categoryID := finance.NewCategoryID(id)
		userIDVO := finance.NewUserID(userID)
		categoryTypeVO := finance.CategoryType(categoryType)

		category, err := finance.NewCategory(categoryID, &userIDVO, name, color, isDefault, categoryTypeVO)
		if err != nil {
			return nil, err
		}
		categories = append(categories, category)
	}

	return categories, rows.Err()
}

// FindDefaultCategories finds all default categories
func (r *PostgresCategoryRepository) FindDefaultCategories(ctx context.Context) ([]*finance.Category, error) {
	rows, err := r.db.QueryContext(ctx,
		"SELECT id, user_id, name, color, is_default, category_type, created_at FROM categories WHERE is_default = TRUE ORDER BY name ASC",
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var categories []*finance.Category
	for rows.Next() {
		var id, userID int
		var name, color, categoryType string
		var isDefault bool
		var createdAt string

		err := rows.Scan(&id, &userID, &name, &color, &isDefault, &categoryType, &createdAt)
		if err != nil {
			return nil, err
		}

		categoryID := finance.NewCategoryID(id)
		userIDVO := finance.NewUserID(userID)
		categoryTypeVO := finance.CategoryType(categoryType)

		category, err := finance.NewCategory(categoryID, &userIDVO, name, color, isDefault, categoryTypeVO)
		if err != nil {
			return nil, err
		}
		categories = append(categories, category)
	}

	return categories, rows.Err()
}
