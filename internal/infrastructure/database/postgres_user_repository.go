package database

import (
	"context"
	"database/sql"
	"panda-pocket/internal/domain/identity"
)

// PostgresUserRepository implements the UserRepository interface using PostgreSQL
type PostgresUserRepository struct {
	db *sql.DB
}

// NewPostgresUserRepository creates a new PostgreSQL user repository
func NewPostgresUserRepository(db *sql.DB) *PostgresUserRepository {
	return &PostgresUserRepository{db: db}
}

// Save saves a user to the database
func (r *PostgresUserRepository) Save(ctx context.Context, user *identity.User) error {
	if user.ID().Value() == 0 {
		// Insert new user
		_, err := r.db.ExecContext(ctx,
			"INSERT INTO users (email, password_hash, created_at) VALUES ($1, $2, $3)",
			user.Email().Value(),
			user.PasswordHash().Value(),
			user.CreatedAt(),
		)
		if err != nil {
			return err
		}

		// Note: PostgreSQL doesn't support LastInsertId() like SQLite
		// The ID will be auto-generated by the SERIAL column
	} else {
		// Update existing user
		_, err := r.db.ExecContext(ctx,
			"UPDATE users SET email = $1, password_hash = $2 WHERE id = $3",
			user.Email().Value(),
			user.PasswordHash().Value(),
			user.ID().Value(),
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// FindByID finds a user by ID
func (r *PostgresUserRepository) FindByID(ctx context.Context, id identity.UserID) (*identity.User, error) {
	var email, passwordHash string
	var createdAt string

	err := r.db.QueryRowContext(ctx,
		"SELECT email, password_hash, created_at FROM users WHERE id = $1",
		id.Value(),
	).Scan(&email, &passwordHash, &createdAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, err
	}

	emailVO, err := identity.NewEmail(email)
	if err != nil {
		return nil, err
	}

	passwordHashVO := identity.NewPasswordHash(passwordHash)

	// Parse created_at
	// Note: In a real implementation, you'd want to parse the timestamp properly
	user := identity.NewUser(id, emailVO, passwordHashVO)

	return user, nil
}

// FindByEmail finds a user by email
func (r *PostgresUserRepository) FindByEmail(ctx context.Context, email identity.Email) (*identity.User, error) {
	var id int
	var passwordHash string
	var createdAt string

	err := r.db.QueryRowContext(ctx,
		"SELECT id, password_hash, created_at FROM users WHERE email = $1",
		email.Value(),
	).Scan(&id, &passwordHash, &createdAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, err
	}

	userID := identity.NewUserID(id)
	passwordHashVO := identity.NewPasswordHash(passwordHash)

	user := identity.NewUser(userID, email, passwordHashVO)

	return user, nil
}

// Delete deletes a user by ID
func (r *PostgresUserRepository) Delete(ctx context.Context, id identity.UserID) error {
	_, err := r.db.ExecContext(ctx, "DELETE FROM users WHERE id = $1", id.Value())
	return err
}

// ExistsByEmail checks if a user exists with the given email
func (r *PostgresUserRepository) ExistsByEmail(ctx context.Context, email identity.Email) (bool, error) {
	var count int
	err := r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM users WHERE email = $1",
		email.Value(),
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count > 0, nil
}
